\documentclass[a4paper, 12pt, titlepage]{article}

% Including needed packages
\usepackage[margin=2cm]{geometry}
\usepackage{amsmath}

\title
{{\em INF 551 - Computer-aided reasoning}\\
Mini-project - Encoding funny games into SAT\\
{\bf Report}}
\author{ROHRMANN Till \and GROSSHANS Nathan}
\date{}

\begin{document}

\maketitle


\section{Introduction}
To complete.


\section{Skyscraper}
The skyscraper game is a little logical game that works like the Sudoku game.
Having a square grid of a fixed size $n$, the goal is to place skyscrapers of
different heights (from 1 to the size of the grid) in the squares of the grid,
such that a skyscraper of each height appears once and only once on each row and
each column, and that the visibility constraints are respected. The visibility
constraints are given by numbers, one on each side of a row or column,
indicating how many buildings must be seen when looking from the given side
towards the skyscraper row or column. There can also be no constraint at all for
a given row or column side.

\subsection{The encoding}
In order to encode the game rules and to obtain the final result we introduced boolean variables $v_{x,y}^h$ saying whether a skyscraper of the size $h$ is on the field $(x,y)$ or not. The game rules are then realized by the following formulas:
	\begin{itemize}
		\item There has to be at least one skyscraper on each field
			\begin{eqnarray}
				\pmb{atLeastOne}&\equiv&\bigwedge_{x=0,y=0}^{n-1} \left(\bigvee_{h=0}^{n-1} v_{x,y}^h \right)
			\end{eqnarray}
		\item There can be at most one skyscraper on each field
			\begin{eqnarray}
				\pmb{atMostOne}&\equiv&\bigwedge_{x=0,y=0}^{n-1} \left( \bigwedge_{h_\not=h_2}^{n-2}\neg(v_{x,y}^{h_1} \wedge v_{x,y}^{h_2})  \right)
			\end{eqnarray}
		\item There can be only one skyscraper of a certain height in each row and column
			\begin{eqnarray}
				\pmb{oneInARow} &\equiv& \bigwedge_{x=0}^{n-1} \left( \bigwedge_{h=0}^{n-1} \left( \bigwedge_{y_1 \not = y_2}^{n-1} \neg(v_{x,y_1}^h \wedge v_{x,y_2}^h) \right) \right) \\
				\pmb{oneInAColumn} &\equiv&  \bigwedge_{y=0}^{n-1} \left( \bigwedge_{h=0}^{n-1} \left( \bigwedge_{x_1 \not = x_2}^{n-1} \neg(v_{x_1,y}^h \wedge v_{x_2,y}^h) \right) \right)
			\end{eqnarray}
	\end{itemize}

In order to realize the constraints, we introduced two predicates $maxSkyscraper$ and $numberSkyscraper$. The first predicate saves which is the highest skyscraper seen so far and the latter counts the number of seen skyscraper up to a given field. Let $D=\{N, E, W, S\}$ be the set of directions. $maxSkyscraper_{d}(x,y,h)$ with $d \in D$ is true iff seen from the field $(x,y)$ in the direction $d$, excluding itself, the highest skyscraper has the height $h-1$. $numberSkyscraper_{d}(x,y,n)$ with $d \in D$ is true iff one can see $n$ skyscrapers from a side in the direction of $d$ up to the field $(x,y)$. For the purpose of readibility, we are going to abbreviate $maxSkyscraper$ by $mS$ and $numberSkyscraper$ by $nS$. Regarding the predicates as functions, then they are defined by:
	\begin{eqnarray}
		mS_{d}(\pmb x) &=& 
		\begin{cases}
			height(\pmb x)+1 & height(\pmb x) \ge mS_{d}(\pmb x + \pmb e_{d})\\
			mS_{d}(\pmb x + \pmb e_{d}) &\text{sinon}
		\end{cases}
		\\
		nS_{d}(\pmb x) &=&
		\begin{cases}
			nS_{d}(\pmb x - \pmb e_{d}) + 1 & height(\pmb x) \ge mS_{d}(\pmb x)\\
			nS_{d}(\pmb x - \pmb e_{d}) &\text{sinon}
		\end{cases}
	\end{eqnarray}
with $\pmb e_{N} = (-1,0)^T, \pmb e_{E} = (0,1)^T, \pmb e_{S} = (1,0)^T,\pmb e_{W} = (0,-1)^T$ and $\pmb x = (x,y)^T$ being the position vector. Moreover, we set the $mS_{d}$ predicate on the respective side to $0$ and the $nS_{d}$ predicate to $1$. The behaviour of $mS$ is modelled by the following formulas:
\begin{itemize}
	\item $mS$ can take only at most one value
	\begin{eqnarray}
		\pmb{mSisAFunction} &\equiv& \bigwedge_{d\in D} \left( \bigwedge_{x=0,y=0}^{n-1} \left( \bigwedge_{v_1 \not = v_2} \neg \left( mS_{d}(x,y,v_1) \wedge mS_{d}(x,y,v_2) \right) \right) \right)
	\end{eqnarray}
	\item Set $mS$ on the borders to zero
	\begin{eqnarray}
		\pmb{mStoZero} &\equiv& \bigwedge_{x=0}^{n-1} mS_{N}(0,x,0) \wedge mS_{E}(x,n-1,0) \wedge \nonumber \\
	&&  mS_{S}(n-1,x,0) \wedge mS_{W}(x,0,0)
	\end{eqnarray}
	\item Value propagation if the skyscraper on the field is smaller than $mS$.
	\begin{eqnarray}
		\pmb{mSvPropC} &\equiv& \bigwedge_{d \in D,x=0,y=0} \bigwedge_{h_1=0}^{n-1} \bigwedge_{h_2 = h_1+1}^{n} \left( v_{x,y}^{h_1} \wedge mS_{d}(\pmb x + \pmb e_{d},h_2) \Rightarrow mS_{d}(\pmb x,h_2) \right)
	\end{eqnarray}
	\item Value propagation if the skyscraper on the field is greater or equal than $mS$.
	\begin{eqnarray}
		\pmb{mSvPropAug} &\equiv& \bigwedge_{d \in D,x=0,y=0} \bigwedge_{h_1=0}^{n-1} \bigwedge_{h_2=h_1}^{n-1} \left( v_{x,y}^{h_2} \wedge mS_{d}(\pmb x + \pmb e_{d},h_1) \Rightarrow mS_{d}(\pmb x,h_2+1) \right)
	\end{eqnarray}
\end{itemize}

The behaviour of $nS$ is given by:
\begin{itemize}
	
\item $nS$ can take only at most one value
	\begin{eqnarray}
		\pmb{nSisAFunction} &\equiv& \bigwedge_{d\in D} \left( \bigwedge_{x=0,y=0}^{n-1} \left( \bigwedge_{v_1 \not = v_2} \neg \left( nS_{d}(x,y,v_1) \wedge nS_{d}(x,y,v_2) \right) \right) \right)
	\end{eqnarray}
	
\item Set $nS$ on the border to one
	\begin{eqnarray}
		\pmb{nStoOne} &\equiv& \bigwedge_{x=0}^{n-1} nS_{N}(n-1,x,1) \wedge nS_{E}(x,0,1) \wedge \nonumber \\
	&&  nS_{S}(0,x,1) \wedge nS_{W}(x,n-1,1)
	\end{eqnarray}
	
\item Value propagation if the skyscraper on the field is smaller than $mS$
	\begin{eqnarray}
		\pmb{nSvPropC} &\equiv& \bigwedge_{\substack{d\in D\\x=0\\y=0}} \bigwedge_{h_{1}=0}^{n-1} \bigwedge_{\substack{h_{2} = h_{1}+1\\h_{3}=0}}^{n} \left( v_{x,y}^{h_1} \wedge mS_d(\pmb x,h_2) \wedge nS_{d^{-1}}(\pmb x - \pmb e_d,h_3) \right. \nonumber \\
	&& \left.\Rightarrow nS_{d^{-1}}(\pmb x - \pmb e_d,h_3) \right)
	\end{eqnarray}
	with $d^{-1}$ being the inverse direction.

	\item Value propagation if the skyscraper is greater or equal than $mS$
	\begin{eqnarray}
		\pmb{nSvPropAug} &\equiv& \bigwedge_{\substack{d\in D\\x=0\\y=0}} \bigwedge_{h_{1}=0}^{n-1} \bigwedge_{\substack{h_{2} = h_{1}\\h_{3}=0}}^{n} \left( v_{x,y}^{h_2} \wedge mS_d(\pmb x,h_1) \wedge nS_{d^{-1}}(\pmb x - \pmb e_d,h_3) \right. \nonumber \\
	&& \left.\Rightarrow nS_{d^{-1}}(\pmb x - \pmb e_d,h_3+1) \right)
	\end{eqnarray}
\end{itemize}

Since all of these formulas are already in CNF form there is no transformation needed. In the last step, the constraints will be specified. This can be easily achieved by constraining the $nS$ at the respective positions to be true for the constraint values. For example, assuming that we have the constraint $c$ for the first line on the left side, then it would be realized by adding $nS_{E}(0,n-1,c)$ as a new clause.


\subsection{How to use the program}
To complete.


\section{Hex-a-Hop}
Hex-a-Hop is a puzzle-based game with hundred levels where the player jumps from
one hexagonal tile to another. The goal, for each level, is to destroy all the
green tiles by visiting them once, without getting trapped or falling into the
water. The levels gradually become more and more difficult, unveiling more and
more new tile types having different behaviours (trampolines, high tiles...).

\subsection{The encoding}

\subsubsection{Representing a level}
A level can be represented by a grid (field) of tiles of different types. As
these tiles are hexagonal, the representation is a bit more complicated as if
they where just squares. In fact, as two successive rows of tiles are
"interleaved" in the sense that the tiles in a row appear each two columns
alternately with the tiles in the adjacent rows, we can represent two rows of
the level in one grid line where the tiles of one row are in the columns with
odd column indexes and the tiles of the other row in the columns with even
column indexes. Naturally, we must then be careful when doing movements around
the grid.

\subsubsection{The main idea of the encoding}
The problem of deciding whether a Hex-a-Hop level can be solved can be
transformed into the parameterized problem of deciding whether a Hex-a-Hop level
can be solved in a given number of steps.
The main idea of the encoding into a SAT CNF formula is to use a set of main
variables indicating the position of the player at each timestep, that is to say
the set of three-dimensional vectors $(x, y, t)$ where $x$ is the abscissa of
the position, $y$ the ordinate of the position and $t$ the discrete timestep.

Obviously, the first set of constraints (clauses) we therefore have to add are
what we've called the {\em state clauses} :
\begin{itemize}
\item At each timestep, the player has to be somewhere, on a tile that is
      accessible (no water), therefore we have the clauses containing all the
      possible positions for a given timestep t :\\
      $\bigwedge \limits_{t=0}^{t_{max}}
       (\bigvee \limits_{\substack{i \in [\![0, x_{max}]\!]\\
				   j \in [\![0, y_{max}]\!]\\
				   (x_i, y_i) \, accessible}}
	(x_i, y_j, t))$

\item But the player can't be at two positions at the same time, therefore we
      have all the clauses containing the negation of two different positions
      for a given timestep t :\\
      $\bigwedge \limits_{t=0}^{t_{max}}
       (\bigwedge \limits_{\substack{\{(i, j), (i', j')\} \in
				     \mathcal{P}({[\![0, x_{max}]\!] \times
						  [\![0, y_{max}]\!]})}
				     }
	(\neg(x_i, y_i, t) \vee \neg(x_{i'}, y_{j'}, t)))
       $
\end{itemize}

\subsubsection{The dynamic type of tiles}
In our first version of the encoding, there were no more variables than those
encoding the position at each timestep. But it is convenient to add some other
variables, auxiliary variables, that help to memorize some useful states.
Dynamic type variables therefore memorize the type a tile has at a given
timestep, as it can be green, turquoise... These variables must be initialized
correctly thanks to the initial state in the level, and their value must be
correctly updated. Therefore, for each position and timestep $(x, y, t)$, we
have the following implications (clauses) that cover all the possible cases :\\
$\neg(x, y, t-1, d_{turquoise}) \Rightarrow (x, y, t, d_{turquoise})\\
 (x, y, t-1, d_{turquoise}) \wedge (x, y, t-1) \Rightarrow
					       \neg(x, y, t, d_{turquoise})\\
 (x, y, t-1, d_{turquoise}) \wedge \neg(x, y, t-1) \Rightarrow
						   (x, y, t, d_{turquoise})\\
 \neg(x, y, t-1, d_{green}) \wedge \neg(x, y, t-1, d_{turquoise}) \Rightarrow
						      \neg(x, y, t, d_{green})\\
 (x, y, t-1, d_{turquoise}) \wedge (x, y, t-1) \Rightarrow
					       (x, y, t, d_{green})\\
 (x, y, t-1, d_{turquoise}) \wedge \neg(x, y, t-1) \Rightarrow
						   \neg(x, y, t, d_{green})\\
 (x, y, t-1, d_{green}) \wedge (x, y, t-1) \Rightarrow
					   \neg(x, y, t, d_{green})\\
 (x, y, t-1, d_{green}) \wedge \neg(x, y, t-1) \Rightarrow
					       (x, y, t, d_{green})
$


\section{Conclusion}
To complete.

\end{document}
